{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Logic Code logic code version 0.0.0 | doc version 0.0.1 Logic code is currently in demo and will have issues. Logic code is a tool to represent , design and simulate logic circuit.It allows users to write code in logic code format and transpile it to c++ code for execution. Features Module based Every component/system in logic code is built out of modules. You can use existing modules or create your own. Simulation Logic code provide the users to simulate the logic circuit but converting the circuit into a c++ code. Which can be compiled to an executable to run the project. Support for automatic build Not everybody likes C++ and Make. So logic code transpiler take care of Makefile generation and build for you. Learn logic code: Install Getting Started with logic code Available components Running Executable and Obtaining Output Features that are not currently available","title":"Logic Code"},{"location":"#logic-code","text":"logic code version 0.0.0 | doc version 0.0.1 Logic code is currently in demo and will have issues. Logic code is a tool to represent , design and simulate logic circuit.It allows users to write code in logic code format and transpile it to c++ code for execution.","title":"Logic Code"},{"location":"#features","text":"","title":"Features"},{"location":"#module-based","text":"Every component/system in logic code is built out of modules. You can use existing modules or create your own.","title":"Module based"},{"location":"#simulation","text":"Logic code provide the users to simulate the logic circuit but converting the circuit into a c++ code. Which can be compiled to an executable to run the project.","title":"Simulation"},{"location":"#support-for-automatic-build","text":"Not everybody likes C++ and Make. So logic code transpiler take care of Makefile generation and build for you.","title":"Support for automatic build"},{"location":"#learn-logic-code","text":"Install Getting Started with logic code Available components Running Executable and Obtaining Output Features that are not currently available","title":"Learn logic code:"},{"location":"gettingStarted/","text":"Getting Started with Logic Code The following content will help you get started with Logic Code. 1. Install Logic Code You may visit the Install page to view more info . Or in short, your system should have g++ , make and Nodejs ( with logic-code module installed globally). 2. Creating project You can create your project using init lcc init <project_name> Then you will be asked \"if you need to add stdcomp c++ library \". At present, logic code transpiles to c++ only and if you wish not to create your own components from scratch type yes. If you are a beginner hit yes. This creates your project directory with the given Project Name. The project follows the following structure myFirstProject // project directory \u251c\u2500\u2500 config.json // configuration of your project \u251c\u2500\u2500 gen // generated Files \u2502 \u251c\u2500\u2500 build // executable files \u2502 \u251c\u2500\u2500 config // internal config like make config etc. \u2502 \u251c\u2500\u2500 lib // c++ libs \u2502 \u2502 \u2514\u2500\u2500 stdcomp // installed stdcomp library \u2502 \u2502 \u251c\u2500\u2500 stdcomp.cpp // c++ file for the library \u2502 \u2502 \u251c\u2500\u2500 stdcomp.h // head file for the library \u2502 \u2502 \u2514\u2500\u2500 stdcomp.json // config for the library \u2502 \u2514\u2500\u2500 tmp // stores temporary files \u2514\u2500\u2500 workspace.lc // workspace file By default, you are only allowed to create your .lc (logic code) files in the project directories , even though you could copy (import) other .lc file from folders inside the project directories. Also note that init has created workspace.lc , this is just a starting point for beginners. You could create a different file and create a wordspace there. 3. Hello World Program Unfortunately, you can't print \"Hello World \" in logic code now. So lets build a simple AND gate. Open workspace.lc in your favourite code editor. It already has some blank template code. Some explanation has given after \"//\" ( Logic code doesn't support comment at present version ). include(\"stdcomp/stdcomp\"); // c++ library to be used during compilation. // stdcomp provides some basic gates to work with. workspace([]=>[]) // workspace is similar to a test bench. { contains{ // defines components we need } wire{ // defines all the wire connections using \"=>\" } init{ // defines inital states } process{ // defines order of execution } } Before starting , have reference of what we are going to build now. Following are the changes to simulate AND gate: Add input (A,B) and output (O) to workspace header. ie workspace([A,B]=>[O]) Add \"And2\" (and gate with 2 inputs) to contains.here and1 is just a variable name of type And2. ie And2 and1; Connect all wires : Input of workspace to input of And2 module. ie A => and1.a; and B => and1.b; Output of And2 module to output of workspace. ie and1.o => O; For now just skip init. Add and1 to process. ie and1; Now our code will be include(\"stdcomp/stdcomp\"); workspace([A,B]=>[O]) { contains{ And2 and1; } wire{ A => and1.a; B => and1.b; and1.o => O; } init{ } process{ and1; } } Just note that using reserved keywords as variable names (including keywords of c++) can cause errors or undesireable results. So to avoid error don't use \"and\" as variable name for And2 gate. 4. Compile code Logic code transpiler transpiles logic code to c++ code, which can further compiled to executable.So make sure g++ and make is installed and added to $PATH. To transpile your logic code file run lcc <filename.lc> here lcc workspace.lc This would generate : a cpp file make config file (make.json) Makefile Logic code takes care of the MakeFile genration and the make.json file holds the config for generating Makefile. To build your project use make make This would generate the executable in the build folder. 5. Run Project Running the executable is similar to running other c++ executables. Also, there are several arguments that can be provided to configure the behaviour. Here we are going to run it in the interactive mode. You could find other arguments here . For Linux : ./gen/build/workspace -m i This would ask you to provide the values for the inputs. Use Tab after each value to provide spacing and after providing all the inputs use Enter or Return, and Output will be calculated and printed. processing at upp = 5. Ctrl + c to exit. A B O 0 0 0 0 1 0 1 0 0 1 1 1 Next: Move to Half Adder","title":"Getting Started"},{"location":"gettingStarted/#getting-started-with-logic-code","text":"The following content will help you get started with Logic Code.","title":"Getting Started with Logic Code"},{"location":"gettingStarted/#1-install-logic-code","text":"You may visit the Install page to view more info . Or in short, your system should have g++ , make and Nodejs ( with logic-code module installed globally).","title":"1. Install Logic Code"},{"location":"gettingStarted/#2-creating-project","text":"You can create your project using init lcc init <project_name> Then you will be asked \"if you need to add stdcomp c++ library \". At present, logic code transpiles to c++ only and if you wish not to create your own components from scratch type yes. If you are a beginner hit yes. This creates your project directory with the given Project Name. The project follows the following structure myFirstProject // project directory \u251c\u2500\u2500 config.json // configuration of your project \u251c\u2500\u2500 gen // generated Files \u2502 \u251c\u2500\u2500 build // executable files \u2502 \u251c\u2500\u2500 config // internal config like make config etc. \u2502 \u251c\u2500\u2500 lib // c++ libs \u2502 \u2502 \u2514\u2500\u2500 stdcomp // installed stdcomp library \u2502 \u2502 \u251c\u2500\u2500 stdcomp.cpp // c++ file for the library \u2502 \u2502 \u251c\u2500\u2500 stdcomp.h // head file for the library \u2502 \u2502 \u2514\u2500\u2500 stdcomp.json // config for the library \u2502 \u2514\u2500\u2500 tmp // stores temporary files \u2514\u2500\u2500 workspace.lc // workspace file By default, you are only allowed to create your .lc (logic code) files in the project directories , even though you could copy (import) other .lc file from folders inside the project directories. Also note that init has created workspace.lc , this is just a starting point for beginners. You could create a different file and create a wordspace there.","title":"2. Creating project"},{"location":"gettingStarted/#3-hello-world-program","text":"Unfortunately, you can't print \"Hello World \" in logic code now. So lets build a simple AND gate. Open workspace.lc in your favourite code editor. It already has some blank template code. Some explanation has given after \"//\" ( Logic code doesn't support comment at present version ). include(\"stdcomp/stdcomp\"); // c++ library to be used during compilation. // stdcomp provides some basic gates to work with. workspace([]=>[]) // workspace is similar to a test bench. { contains{ // defines components we need } wire{ // defines all the wire connections using \"=>\" } init{ // defines inital states } process{ // defines order of execution } } Before starting , have reference of what we are going to build now. Following are the changes to simulate AND gate: Add input (A,B) and output (O) to workspace header. ie workspace([A,B]=>[O]) Add \"And2\" (and gate with 2 inputs) to contains.here and1 is just a variable name of type And2. ie And2 and1; Connect all wires : Input of workspace to input of And2 module. ie A => and1.a; and B => and1.b; Output of And2 module to output of workspace. ie and1.o => O; For now just skip init. Add and1 to process. ie and1; Now our code will be include(\"stdcomp/stdcomp\"); workspace([A,B]=>[O]) { contains{ And2 and1; } wire{ A => and1.a; B => and1.b; and1.o => O; } init{ } process{ and1; } } Just note that using reserved keywords as variable names (including keywords of c++) can cause errors or undesireable results. So to avoid error don't use \"and\" as variable name for And2 gate.","title":"3. Hello World Program"},{"location":"gettingStarted/#4-compile-code","text":"Logic code transpiler transpiles logic code to c++ code, which can further compiled to executable.So make sure g++ and make is installed and added to $PATH. To transpile your logic code file run lcc <filename.lc> here lcc workspace.lc This would generate : a cpp file make config file (make.json) Makefile Logic code takes care of the MakeFile genration and the make.json file holds the config for generating Makefile. To build your project use make make This would generate the executable in the build folder.","title":"4. Compile code"},{"location":"gettingStarted/#5-run-project","text":"Running the executable is similar to running other c++ executables. Also, there are several arguments that can be provided to configure the behaviour. Here we are going to run it in the interactive mode. You could find other arguments here . For Linux : ./gen/build/workspace -m i This would ask you to provide the values for the inputs. Use Tab after each value to provide spacing and after providing all the inputs use Enter or Return, and Output will be calculated and printed. processing at upp = 5. Ctrl + c to exit. A B O 0 0 0 0 1 0 1 0 0 1 1 1","title":"5. Run Project"},{"location":"gettingStarted/#next-move-to-half-adder","text":"","title":"Next: Move to Half Adder"},{"location":"gettingStarted2/","text":"Adder Circuit This tutorial will help you understant the basic concepts of logic code and will cover few more advanced concepts like module, copy and include. 1. Create Project Create a new Project using init lcc init adder 2. Create a Half Addder inside workspace.lc First, understand the circuit, do some research if you are not familiar. In short : SUM = A XOR B // where A,B are inputs Carry = A AND B 3. Half Adder program include(\"stdcomp/stdcomp\"); workspace([A,B]=>[SUM,Carry]) { contains{ Xor2 xor1; And2 and1; } wire{ A => xor1.a; B => xor1.b; xor1.o => SUM; A => and1.a; B => and1.b; and1.o => Carry; } init{ [A] = [0]; [B] = [0]; } process{ xor1; and1; } } Note , here we have used init section here, just to give you an understanding of it. Even though this is not necessary in this case, there may be circuits where output depends on the previous states, for instance flipflops. Remember you only allowed initilize values for input ports in workspace and output ports in modules, as rest of the ports depend on other ports. 4. Complie the code and Run Compile the code using // transpile lc to c++ code lcc workspace.lc // build make // execute in interactive mode ./gen/build/workspace -m i processing at upp = 5. Ctrl + c to exit. A B O 0 0 0 0 1 0 1 0 0 1 1 1 5. Creating a module Modules allow us to create components ( in this case half adder ) and reuse it, similar to functions. Module also follows similar structure to workspace , but does have a name. You could create inside the workspace.lc file itself (doing now) or in a define it in a separate file (next section) and import using copy. A blank module structure would look like : module <ModuleName>([]=>[]) { contains{ } wire{ } init{ } process{ } } Note, Modules must be defined before its usage. Half adder module would look like : module HalfAdder([a,b]=>[sum,carry]) { contains{ Xor2 xor1; And2 and1; } wire{ a => xor1.a; b => xor1.b; xor1.o => sum; a => and1.a; b => and1.b; and1.o => carry; } init{ [sum] = [0]; [carry] = [0]; } process{ xor1; and1; } } We have changed some port name (example: A to a, SUM to sum etc), to help you understand better. Also we have changed the init section from a,b to sum, carry. As we have created HalfAdder module we have to change workspace to use this module. workspace([A,B]=>[S,C]) { contains{ HalfAdder ha; } wire{ A => ha.a; B => ha.b; ha.sum => S; ha.carry => C; } init{ [A] = [0]; [B] = [0]; } process{ ha; } } Now our workspace.lc would look like : include(\"stdcomp/stdcomp\"); module HalfAdder([a,b]=>[sum,carry]) { contains{ Xor2 xor1; And2 and1; } wire{ a => xor1.a; b => xor1.b; xor1.o => sum; a => and1.a; b => and1.b; and1.o => carry; } init{ [sum] = [0]; [carry] = [0]; } process{ xor1; and1; } } workspace([A,B]=>[S,C]) { contains{ HalfAdder ha; } wire{ A => ha.a; B => ha.b; ha.sum => S; ha.carry => C; } init{ [A] = [0]; [B] = [0]; } process{ ha; } } Try running your project using : // transpile lc to c++ code lcc workspace.lc // build make // execute in interactive mode ./gen/build/workspace -m i And you should get the same output as before: processing at upp = 5. Ctrl + c to exit. A B O 0 0 0 0 1 0 1 0 0 1 1 1 6. Splitting into separate files Projects can become big soon and defining everything in a single file can no longer be possible. In order to avoid this logic code provide 2 ways to split you projects to smaller files. 1. include statement Technically, include statements only helps you to import modules and gates from c++ files. But if your designed circuit in the c++ way [check Create your own c++ components ]. you could import it using include like you imported stdcomp. ie include(\"stdcomp/stdcomp\"); include(\"<path to cpp component library's json file without .json\"); 2. copy statement Copy statement allows you to import modules from another .lc file. Currently it is not possible to import only a particular component from a lc file, when you use copy every component in that file is available. copy(\"path to the lc file\"); 7. Full Adder using Half Adder This section helps you understand the use of copy statement. First understand the circuit. In order to simplify the code lets move our half adder to another file. Create a file named halfAdder.lc in the project directory and move our HalfAdder module to it. It is also important to include stdcomp in halfAdder.lc as our circuit depends on basic gates. So halfAdder.lc would look like: include(\"stdcomp/stdcomp\"); module HalfAdder([a,b]=>[sum,carry]) { contains{ Xor2 xor1; And2 and1; } wire{ a => xor1.a; b => xor1.b; xor1.o => sum; a => and1.a; b => and1.b; and1.o => carry; } init{ [a] = [0]; [b] = [0]; } process{ xor1; and1; } } And now lets create Full adder in our workspace.lc include(\"stdcomp/stdcomp\"); copy(\"halfAdder.lc\"); workspace([A,B,Cin]=>[SUM,Cout]) { contains{ HalfAdder ha1,ha2; Or2 or1; } wire{ A => ha1.a; B => ha1.b; ha1.sum => ha2.b; ha1.carry => or1.b; Cin => ha2.a; ha2.sum => SUM; ha2.carry => or1.a; or1.o => Cout; } init{ [A] = [0]; [B] = [0]; [Cin] = [0]; } process{ ha1; ha2; or1; } } Try running your project using : // transpile lc to c++ code lcc workspace.lc // build make // execute in interactive mode ./gen/build/workspace -m i Output: processing at upp = 5. Ctrl + c to exit. A B Cin SUM Cout 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 0 1 1 0 1 1 0 0 1 0 1 0 1 0 1 1 1 0 0 1 1 1 1 1 1 You have reached the end of the getting started section.Now you can explore logic code your own. Check : Components available in stdcomp Rules to understand the basic rules of logic code. Running modes to see different modes under wich you can run your code Also make sure you check the currently unsupported features","title":"Building A Full Adder"},{"location":"gettingStarted2/#adder-circuit","text":"This tutorial will help you understant the basic concepts of logic code and will cover few more advanced concepts like module, copy and include.","title":"Adder Circuit"},{"location":"gettingStarted2/#1-create-project","text":"Create a new Project using init lcc init adder","title":"1. Create Project"},{"location":"gettingStarted2/#2-create-a-half-addder-inside-workspacelc","text":"First, understand the circuit, do some research if you are not familiar. In short : SUM = A XOR B // where A,B are inputs Carry = A AND B","title":"2. Create a Half Addder inside workspace.lc"},{"location":"gettingStarted2/#3-half-adder-program","text":"include(\"stdcomp/stdcomp\"); workspace([A,B]=>[SUM,Carry]) { contains{ Xor2 xor1; And2 and1; } wire{ A => xor1.a; B => xor1.b; xor1.o => SUM; A => and1.a; B => and1.b; and1.o => Carry; } init{ [A] = [0]; [B] = [0]; } process{ xor1; and1; } } Note , here we have used init section here, just to give you an understanding of it. Even though this is not necessary in this case, there may be circuits where output depends on the previous states, for instance flipflops. Remember you only allowed initilize values for input ports in workspace and output ports in modules, as rest of the ports depend on other ports.","title":"3. Half Adder program"},{"location":"gettingStarted2/#4-complie-the-code-and-run","text":"Compile the code using // transpile lc to c++ code lcc workspace.lc // build make // execute in interactive mode ./gen/build/workspace -m i processing at upp = 5. Ctrl + c to exit. A B O 0 0 0 0 1 0 1 0 0 1 1 1","title":"4. Complie the code and Run"},{"location":"gettingStarted2/#5-creating-a-module","text":"Modules allow us to create components ( in this case half adder ) and reuse it, similar to functions. Module also follows similar structure to workspace , but does have a name. You could create inside the workspace.lc file itself (doing now) or in a define it in a separate file (next section) and import using copy. A blank module structure would look like : module <ModuleName>([]=>[]) { contains{ } wire{ } init{ } process{ } } Note, Modules must be defined before its usage. Half adder module would look like : module HalfAdder([a,b]=>[sum,carry]) { contains{ Xor2 xor1; And2 and1; } wire{ a => xor1.a; b => xor1.b; xor1.o => sum; a => and1.a; b => and1.b; and1.o => carry; } init{ [sum] = [0]; [carry] = [0]; } process{ xor1; and1; } } We have changed some port name (example: A to a, SUM to sum etc), to help you understand better. Also we have changed the init section from a,b to sum, carry. As we have created HalfAdder module we have to change workspace to use this module. workspace([A,B]=>[S,C]) { contains{ HalfAdder ha; } wire{ A => ha.a; B => ha.b; ha.sum => S; ha.carry => C; } init{ [A] = [0]; [B] = [0]; } process{ ha; } } Now our workspace.lc would look like : include(\"stdcomp/stdcomp\"); module HalfAdder([a,b]=>[sum,carry]) { contains{ Xor2 xor1; And2 and1; } wire{ a => xor1.a; b => xor1.b; xor1.o => sum; a => and1.a; b => and1.b; and1.o => carry; } init{ [sum] = [0]; [carry] = [0]; } process{ xor1; and1; } } workspace([A,B]=>[S,C]) { contains{ HalfAdder ha; } wire{ A => ha.a; B => ha.b; ha.sum => S; ha.carry => C; } init{ [A] = [0]; [B] = [0]; } process{ ha; } } Try running your project using : // transpile lc to c++ code lcc workspace.lc // build make // execute in interactive mode ./gen/build/workspace -m i And you should get the same output as before: processing at upp = 5. Ctrl + c to exit. A B O 0 0 0 0 1 0 1 0 0 1 1 1","title":"5. Creating a module"},{"location":"gettingStarted2/#6-splitting-into-separate-files","text":"Projects can become big soon and defining everything in a single file can no longer be possible. In order to avoid this logic code provide 2 ways to split you projects to smaller files.","title":"6. Splitting into separate files"},{"location":"gettingStarted2/#1-include-statement","text":"Technically, include statements only helps you to import modules and gates from c++ files. But if your designed circuit in the c++ way [check Create your own c++ components ]. you could import it using include like you imported stdcomp. ie include(\"stdcomp/stdcomp\"); include(\"<path to cpp component library's json file without .json\");","title":"1. include statement"},{"location":"gettingStarted2/#2-copy-statement","text":"Copy statement allows you to import modules from another .lc file. Currently it is not possible to import only a particular component from a lc file, when you use copy every component in that file is available. copy(\"path to the lc file\");","title":"2. copy statement"},{"location":"gettingStarted2/#7-full-adder-using-half-adder","text":"This section helps you understand the use of copy statement. First understand the circuit. In order to simplify the code lets move our half adder to another file. Create a file named halfAdder.lc in the project directory and move our HalfAdder module to it. It is also important to include stdcomp in halfAdder.lc as our circuit depends on basic gates. So halfAdder.lc would look like: include(\"stdcomp/stdcomp\"); module HalfAdder([a,b]=>[sum,carry]) { contains{ Xor2 xor1; And2 and1; } wire{ a => xor1.a; b => xor1.b; xor1.o => sum; a => and1.a; b => and1.b; and1.o => carry; } init{ [a] = [0]; [b] = [0]; } process{ xor1; and1; } } And now lets create Full adder in our workspace.lc include(\"stdcomp/stdcomp\"); copy(\"halfAdder.lc\"); workspace([A,B,Cin]=>[SUM,Cout]) { contains{ HalfAdder ha1,ha2; Or2 or1; } wire{ A => ha1.a; B => ha1.b; ha1.sum => ha2.b; ha1.carry => or1.b; Cin => ha2.a; ha2.sum => SUM; ha2.carry => or1.a; or1.o => Cout; } init{ [A] = [0]; [B] = [0]; [Cin] = [0]; } process{ ha1; ha2; or1; } } Try running your project using : // transpile lc to c++ code lcc workspace.lc // build make // execute in interactive mode ./gen/build/workspace -m i Output: processing at upp = 5. Ctrl + c to exit. A B Cin SUM Cout 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 0 1 1 0 1 1 0 0 1 0 1 0 1 0 1 1 1 0 0 1 1 1 1 1 1 You have reached the end of the getting started section.Now you can explore logic code your own. Check : Components available in stdcomp Rules to understand the basic rules of logic code. Running modes to see different modes under wich you can run your code Also make sure you check the currently unsupported features","title":"7. Full Adder using Half Adder"},{"location":"install/","text":"Install Logic code This page includes information regarding the installation of logic code on your system. Install Node.js Logic code and its core components are built using Node.js . To get started, install node on your system. Steps may vary depending upon your device. visit the official website and follow the instructions to install node . Node.js official website Install g++ and make Logic Code requires a c++ compile and make to create executables. Also, steps for installation also may vary depending on your system. Unfortunately, we cannot provide you with steps for both of these installs. Install Logic Code package globally To install logic code globally update here","title":"Install"},{"location":"install/#install-logic-code","text":"This page includes information regarding the installation of logic code on your system.","title":"Install Logic code"},{"location":"install/#install-nodejs","text":"Logic code and its core components are built using Node.js . To get started, install node on your system. Steps may vary depending upon your device. visit the official website and follow the instructions to install node . Node.js official website","title":"Install Node.js"},{"location":"install/#install-g-and-make","text":"Logic Code requires a c++ compile and make to create executables. Also, steps for installation also may vary depending on your system. Unfortunately, we cannot provide you with steps for both of these installs.","title":"Install g++ and make"},{"location":"install/#install-logic-code-package-globally","text":"To install logic code globally update here","title":"Install Logic Code package globally"},{"location":"runningExe/","text":"Arguments for running Executable ./exe represents the generated executable file. This may vary depending on your OS. 1. Modes (-m ) This allows the user to select how the program should run . ./exe -m <mode> 1.1 Modes available Direct input (d) In this method, users can provide input directly as arguments. It requires -i to give the inputs.Note the number of inputs should match the number of arguments after -i. The order of the input is same as that of the input declaration in the workspace header. ./exe -m d -i 0 1 1 // there 3 inputs which are given 0,1,1. Interactive mode (i) This mode allows the user to provide the input signal at every step using tab (spacing) and return key. ./exe -m i File mode (f) This mode allows the user to provide a csv file with inputs to generate an output file with results of the input file. You have to use -f to provide the input file. ./exe -m f -f <path to input file> The input file should follow the following format: name:<name of component> output_file_name:<name of the output file> upp:7 totaltime:1400_m_s <time has not yet implemented, so skip for now> interval:200_m_s <time has not yet implemented> end:<number of inputs> <inputs at a first stage saperated by commas> <inputs at a second stage saperated by commas> <inputs at a third stage saperated by commas> <inputs at a fourth stage saperated by commas> A sample input.csv file for a full adder would look like: name:FullAdder output_file_name:output.csv upp:7 totaltime:1400_m_s interval:200_m_s end:3 0,0,0 0,0,1 0,1,0 0,1,1 1,0,0 1,0,1 1,1,0 1,1,1 If want to see the output while processing use \"-p y\" . ` ./exe -m f -f <path to input file> -p y","title":"Arguments for running Executable"},{"location":"runningExe/#arguments-for-running-executable","text":"./exe represents the generated executable file. This may vary depending on your OS.","title":"Arguments for running Executable"},{"location":"runningExe/#1-modes-m","text":"This allows the user to select how the program should run . ./exe -m <mode>","title":"1. Modes (-m )"},{"location":"runningExe/#11-modes-available","text":"","title":"1.1 Modes available"},{"location":"runningExe/#direct-input-d","text":"In this method, users can provide input directly as arguments. It requires -i to give the inputs.Note the number of inputs should match the number of arguments after -i. The order of the input is same as that of the input declaration in the workspace header. ./exe -m d -i 0 1 1 // there 3 inputs which are given 0,1,1.","title":"Direct input (d)"},{"location":"runningExe/#interactive-mode-i","text":"This mode allows the user to provide the input signal at every step using tab (spacing) and return key. ./exe -m i","title":"Interactive mode (i)"},{"location":"runningExe/#file-mode-f","text":"This mode allows the user to provide a csv file with inputs to generate an output file with results of the input file. You have to use -f to provide the input file. ./exe -m f -f <path to input file> The input file should follow the following format: name:<name of component> output_file_name:<name of the output file> upp:7 totaltime:1400_m_s <time has not yet implemented, so skip for now> interval:200_m_s <time has not yet implemented> end:<number of inputs> <inputs at a first stage saperated by commas> <inputs at a second stage saperated by commas> <inputs at a third stage saperated by commas> <inputs at a fourth stage saperated by commas> A sample input.csv file for a full adder would look like: name:FullAdder output_file_name:output.csv upp:7 totaltime:1400_m_s interval:200_m_s end:3 0,0,0 0,0,1 0,1,0 0,1,1 1,0,0 1,0,1 1,1,0 1,1,1 If want to see the output while processing use \"-p y\" . ` ./exe -m f -f <path to input file> -p y","title":"File mode (f)"},{"location":"stdcomp/","text":"Components This gives you information about the components in the stdcomp library. 1. Not gate (Inverter) This produces the inverted state of the input. Gate Inputs Outputs Not a o 2. Controlled Inverter This act as an Inverter when the control pin is high else low. Gate Inputs Outputs CtrlInverter a, c(control) o 3. Buffer This component reproduces the input at the output. Gate Inputs Outputs Buffer a o 4. Controlled Buffer This acts as a Buffer when the control pin is high else low. Gate Inputs Outputs CtrlBuffer a, c(control) o 5. And This produces high only when every input is high. Gate Inputs Outputs And2 a,b o And3 a,b,c o And4 a,b,c,d o 6. Or This produces high signal when at least one of the input is high. Gate Inputs Outputs Or2 a,b o Or3 a,b,c o Or4 a,b,c,d o 7. Nand It produces output which is complement to that of an AND gate. Gate Inputs Outputs Nand2 a,b o Nand3 a,b,c o Nand4 a,b,c,d o 8. Nor It produces output which is complement to that of an OR gate. Gate Inputs Outputs Nor2 a,b o Nor3 a,b,c o Nor4 a,b,c,d o 9. Xor The output of an XOR gate is high only when odd number of inputs are high Gate Inputs Outputs Xor2 a,b o Xor3 a,b,c o Xor4 a,b,c,d o 10. Xnor The output of an XNOR gate is high only when even number of inputs are high Gate Inputs Outputs Xnor2 a,b o Xnor3 a,b,c o Xnor4 a,b,c,d o 11. Positive Trigger The output of this module is high when input changes from low to high Gate Inputs Outputs PosTrig i o 11. Negative Trigger The output of this module is high when input changes from high to low. Gate Inputs Outputs NegTrig i o","title":"Components"},{"location":"stdcomp/#components","text":"This gives you information about the components in the stdcomp library.","title":"Components"},{"location":"stdcomp/#1-not-gate-inverter","text":"This produces the inverted state of the input. Gate Inputs Outputs Not a o","title":"1. Not gate (Inverter)"},{"location":"stdcomp/#2-controlled-inverter","text":"This act as an Inverter when the control pin is high else low. Gate Inputs Outputs CtrlInverter a, c(control) o","title":"2. Controlled Inverter"},{"location":"stdcomp/#3-buffer","text":"This component reproduces the input at the output. Gate Inputs Outputs Buffer a o","title":"3. Buffer"},{"location":"stdcomp/#4-controlled-buffer","text":"This acts as a Buffer when the control pin is high else low. Gate Inputs Outputs CtrlBuffer a, c(control) o","title":"4. Controlled Buffer"},{"location":"stdcomp/#5-and","text":"This produces high only when every input is high. Gate Inputs Outputs And2 a,b o And3 a,b,c o And4 a,b,c,d o","title":"5. And"},{"location":"stdcomp/#6-or","text":"This produces high signal when at least one of the input is high. Gate Inputs Outputs Or2 a,b o Or3 a,b,c o Or4 a,b,c,d o","title":"6. Or"},{"location":"stdcomp/#7-nand","text":"It produces output which is complement to that of an AND gate. Gate Inputs Outputs Nand2 a,b o Nand3 a,b,c o Nand4 a,b,c,d o","title":"7. Nand"},{"location":"stdcomp/#8-nor","text":"It produces output which is complement to that of an OR gate. Gate Inputs Outputs Nor2 a,b o Nor3 a,b,c o Nor4 a,b,c,d o","title":"8. Nor"},{"location":"stdcomp/#9-xor","text":"The output of an XOR gate is high only when odd number of inputs are high Gate Inputs Outputs Xor2 a,b o Xor3 a,b,c o Xor4 a,b,c,d o","title":"9. Xor"},{"location":"stdcomp/#10-xnor","text":"The output of an XNOR gate is high only when even number of inputs are high Gate Inputs Outputs Xnor2 a,b o Xnor3 a,b,c o Xnor4 a,b,c,d o","title":"10. Xnor"},{"location":"stdcomp/#11-positive-trigger","text":"The output of this module is high when input changes from low to high Gate Inputs Outputs PosTrig i o","title":"11. Positive Trigger"},{"location":"stdcomp/#11-negative-trigger","text":"The output of this module is high when input changes from high to low. Gate Inputs Outputs NegTrig i o","title":"11. Negative Trigger"},{"location":"unsupported/","text":"Unsupported features These features mentioned below are not yet implemented in logic code and users won't be able to do them in logic code. Note, this is not a to-do list.These features may or may not be included in future versions. Bit width Automatically detect direction of wire Automatically generate process based on contains order z and x states Unconnected wire detection Comments Workbench software for logic code Code highlighting and auto complete extension for VSCodium Programming real devices Probe at any point in circuit VCD file support Support for time signals","title":"Unsupported features"},{"location":"unsupported/#unsupported-features","text":"These features mentioned below are not yet implemented in logic code and users won't be able to do them in logic code. Note, this is not a to-do list.These features may or may not be included in future versions. Bit width Automatically detect direction of wire Automatically generate process based on contains order z and x states Unconnected wire detection Comments Workbench software for logic code Code highlighting and auto complete extension for VSCodium Programming real devices Probe at any point in circuit VCD file support Support for time signals","title":"Unsupported features"}]}